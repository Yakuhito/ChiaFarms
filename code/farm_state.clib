; a farm's state is built as follows:
; state - list
;   0: level - number
;   1: plant_capacity - number
;   2: upgrade_cost - number
;   3: plants - list
;        0: last_harvest_block
;        1: number
(
    (defconstant HARVEST_TIME 1152) ; 192 = 10 minutes, so 192 * 6 = 1 hour (approx)
    (include farm_actions.clib)
    (include farm_cat_things.clib)
    (include announcements.clib)
    (include condition_codes.clib)

    (defun-inline farm_state_level (state) (f state ))
    (defun-inline farm_state_plant_capacity (state) (f (r state)))
    (defun-inline farm_state_upgrade_cost (state) (f (r (r state))))
    (defun-inline farm_state_plants (state) (f (r (r (r state)))))

    (defun-inline farm_state_plant_last_harvest_block (plant) (f plant))
    (defun-inline farm_state_plant_number (plant) (f (r plant))

    ; @desc adds some plants to the 'plants' list
    ; @param state_plants: list of plants
    ; @param plants_to_add: a single plant element (last_harvest_block number)
    ; @returns a new state_plants list
    (defun add_plants_to_list (state_plants plants_to_add)
        (if state_plants
            (if (= (farm_state_plant_last_harvest_block (f state_plants)) (farm_state_plant_last_harvest_block plants_to_add))
                (c
                    (c
                        (farm_state_plant_last_harvest_block (f state_plants))
                        (+ (farm_state_plant_number (f state_plants)) (farm_state_plant_number plants_to_add))
                    )
                    (r state_plants)
                )
            ; else
                (c (f state_plants) (add_plants_to_list (r state_plants) plants_to_add)) ; move to the next item
            )
        ; else
            plants_to_add; state_plants is empty; append plants_to_add at the end
        )
    )

    ; @desc computes the number of times a plant should be harvested
    ;       e.g. if a plant makes seeds every 2 hours and 10 hours have passed, this function should return 5
    ; @param last_harvest_block the last block number that the plant was harvested on
    ; @param current_block the current block number
    ; @returns no_harvests (read @desc)
    (defun-inline get_no_harvests (last_harvest_block current_block)
        (/
            (- current_block last_harvest_block)
            HARVEST_TIME
        )
    )

    ; @desc returns the seeds generated by a plant object
    ; @param plant a single plant element (last_harvest_block number)
    ; @param current_block the current block number
    ; @returns the amount of seeds that should be minted
    (defun-inline get_seeds_from_plant (plant current_block)
        (*
            (get_no_harvests (farm_state_plant_last_harvest_block plant) current_block)
            (farm_state_plant_number plant)
        )
    )

    ; @desc computes th total number of seeds that should be minted after harvesting
    ; @param plants is state_plants (list of plants that need to be harvested)
    ; @param current_block the current block number
    ; @param seeds accumulator
    ; @returns number of seeds
    (defun get_total_seeds (plants current_block)
        (if plants
            (+
                (get_seeds_from_plant (f plants) current_block)
                (get_total_seeds (r plants) current_block)
            )
        ; else
            ()
        )
    )    

    ; @desc computes the updated plant object (after harvest)
    ; @param plant a single plant element (last_harvest_block number)
    ; @param current_block the current block number
    ; @returns a new plant object
    (defun-inline get_plant_after_harvest (plant current_block)
        (c
            (+
                (farm_state_plant_last_harvest_block plant)
                (* HARVEST_TIME (get_no_harvests (farm_state_plant_last_harvest_block plant) current_block))
            )
            (farm_state_plant_number plant)
        )
    )

    ; @desc computes the updated plant list (after harvest)
    ; @param a list of plant elements (last_harvest_block number)
    ; @param current_block the current block number
    ; @returns the updated list
    (defun-inline get_plants_after_harvest (plants current_block)
        (if plants
            (c
                (get_plant_after_harvest (f plants) current_block)
                (get_plants_after_harvest (r plants) current_block)
            )
        ; else
            ()
        )
    )

    ; @desc handles the logic for upgrading a farm
    ; @returns a new state
    (defun-inline farm_upgrade_logic (state)
        (if (> 13 farm_state_level) ; max farm level is 13
            ; payment is being taken care of by farm_upgrade_security
            (list
                (+ (farm_state_level state) 1) ; level += 1
                (+ (* 2 (farm_state_plant_capacity state)) 1) ; plant_capacity = plant_capacity * 2 + 1
                (* 2 (farm_state_upgrade_cost state)) ; upgrade_cost *= 2
                (farm_state_plants farm)
            )
        ; else
            (x)
        )
    )

    ; @desc handles the logic for harvesting a farm
    ; @returns a new state
    (defun-inline farm_harvest_logic (state args)
        (list
            (farm_state_level state)
            (farm_state_plant_capacity state)
            (farm_state_upgrade_cost state)
            (get_plants_after_harvest (farm_state_plants farm) (f args))
        )
    )

    ; @desc handles the logic for planting seeds in a farm
    ; @returns a new state
    (defun-inline farm_plant_logic (state args)
         (list
            (farm_state_level state)
            (farm_state_plant_capacity state)
            (farm_state_upgrade_cost state)
            (add_plants_to_list (farm_state_plants farm)
                (c
                    (+ (f args) (* 6 HARVEST_TIME)) ; seeds turn into plants after 6 'harvest eras' (~ 6 hours)
                    (f (r args)) ; number
                )
            )
        )
    )

    (defconstant ANNOUNCEMENT_MORPH_BYTE 0xca)

    ; @desc handles announcements for upgrading a farm
    ; @returns list od conditions
    (defun-inline farm_upgrade_announcements (state cat_things)
        ; just destroy BUCKs
        (list
            (list CREATE_PUZZLE_ANNOUNCEMENT
                (sha256 FARM_REQUEST_BUCK_BURN (* -1000 (farm_state_upgrade_cost state)) (buck_coin_id cat_things))
            ) ; can't use addition for obvious reasons
            (list ASSERT_COIN_ANNOUNCEMENT (sha256 (buck_coin_id cat_things)
                ; first sha256 is used to calculate announcementId
                ; second is used because CATs 'morph' all announcements from TAILs
                ; third is used to 'pack' announcement data
                (sha256 ANNOUNCEMENT_MORPH_BYTE (sha256 BUCK_ANNOUNCE_BURN (* -1000 (farm_state_upgrade_cost state))))
            ))
        )
    )

    ; @desc handles announcements for harvesting a farm
    ; @returns list od conditions
    (defun-inline farm_harvest_announcements (state args cat_things owner_pubkey)
        ; check current_block and send SEEDs + sig
        (list
            (list ASSERT_HEIGHT_ABSOLUTE (f args))
            (list CREATE_PUZZLE_ANNOUNCEMENT
                (sha256 FARM_REQUEST_SEED_MINT
                    (get_total_seeds (farm_state_plants state) (f args)) (seed_coin_id cat_things)
                )
            ) ; can't use addition for obvious reasons
            (list ASSERT_COIN_ANNOUNCEMENT (sha256 (seed_coin_id cat_things)
                ; first sha256 is used to calculate announcementId
                ; second is used because CATs 'morph' all announcements from TAILs
                ; third is used to 'pack' announcement data
                (sha256 ANNOUNCEMENT_MORPH_BYTE (sha256 SEED_ANNOUNCE_MINT (get_total_seeds (farm_state_plants state) (f args))))
            ))
            (list AGG_SIG_ME owner_pubkey (sha256 args))
        )
    )

    ; @desc handles announcements for planting seeds in a farm
    ; @returns list od conditions
    (defun-inline farm_plant_announcements (state args cat_things owner_pubkey)
        ; check current_block and burn seeds (don't worry - they are actually getting planted) + sig
        (list
            (list ASSERT_HEIGHT_ABSOLUTE (f args))
            (list CREATE_PUZZLE_ANNOUNCEMENT
                (sha256 FARM_REQUEST_SEED_BURN
                    (f (r args)) (seed_coin_id cat_things)
                )
            ) ; can't use addition for obvious reasons
            (list ASSERT_COIN_ANNOUNCEMENT (sha256 (seed_coin_id cat_things)
                ; first sha256 is used to calculate announcementId
                ; second is used because CATs 'morph' all announcements from TAILs
                ; third is used to 'pack' announcement data
                (sha256 ANNOUNCEMENT_MORPH_BYTE (sha256 SEED_ANNOUNCE_BURN (f (r args))))
            ))
            (list AGG_SIG_ME owner_pubkey (sha256 args))
        )
    )

    ; @desc handles announcements for transfering a farm to a new owner
    ; @returns list od conditions
    (defun-inline farm_transfer_announcements (state args cat_things owner_pubkey)
        ; check sig
        (list
            (list AGG_SIG_ME owner_pubkey (sha256 args))
        )
    )

    ; @desc responsible for updating a new state (logic; everything except announcements)
    ; @param action something from [FARM_UPGRADE, FARM_HARVEST, FARM_PLANT]
    ; @param args atguments for the said action (see farm_actions.clib for format)
    ; @returns a new state
    (defun-inline update_farm_state (state action args cat_things) (
        ; 1. Upgrade
        (if (= action FARM_UPGRADE)
            (farm_upgrade_logic state)
        ; else 
            ; 2. Harvest (get_total_seeds + get_plants_after_harvest)
            (if (= action FARM_HARVEST)
                (farm_harvest_logic state args)
            ; else
                ; 3. Plant seeds
                (if (= action FARM_PLANT)
                    (farm_plant_logic state args)
                ; else
                    state ; transfer or invalid action
                )
            )
        )
    ))

    ; @desc responsible for SECURITY (e.g. announcement)
    ; @param action something from [FARM_UPGRADE, FARM_HARVEST, FARM_PLANT]
    ; @param args atguments for the said action (see farm_actions.clib for format)
    ; @returns conditions
    (defun-inline get_state_update_conditions (state action args cat_things owner_pubkey) (
        ; 1. Upgrade
        (if (= action FARM_UPGRADE)
            (farm_upgrade_announcements state) ; anyone can upgrade farms
        ; else 
            ; 2. Harvest (get_total_seeds + get_plants_after_harvest)
            (if (= action FARM_HARVEST)
                (farm_harvest_announcements state args cat_things owner_pubkey)
            ; else
                ; 3. Plant seeds
                (if (= action FARM_PLANT)
                    (farm_plant_announcements state args cat_things owner_pubkey)
                ; else
                    (if (= action FARM_TRANSFER)
                        (farm_transfer_announcements state args cat_things owner_pubkey)
                    ; else
                        (x) ; unknown action
                    )
                )
            )
        )
    ))
)
